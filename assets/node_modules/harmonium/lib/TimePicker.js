'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TimeContainer = exports.TimeInput = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _lodash = require('lodash');

var _TimeInput = require('./TimePicker/TimeInput');

var _TimeInput2 = _interopRequireDefault(_TimeInput);

var _TimeContainer = require('./TimePicker/TimeContainer');

var _TimeContainer2 = _interopRequireDefault(_TimeContainer);

var _InputHelpText = require('./InputHelpText');

var _InputHelpText2 = _interopRequireDefault(_InputHelpText);

var _InputErrors = require('./InputErrors');

var _InputErrors2 = _interopRequireDefault(_InputErrors);

var _luxon = require('luxon');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Determines if time type inputs are well supported on this platform
 * @return {boolean} true if time type inputs are well supported, false otherwise
 */
function useGoodTimeInput() {
  if (typeof window === 'undefined') {
    return true;
  } else {
    var element = document.createElement('input');

    element.type = 'time';
    return element.type === 'time';
  }
}

/* TODO FEATURES:
    allow keyboard up & down to increment/decrement for accessibility concerns,
    overrides,
    allow setting how much each button should increment,
    allowing min and/or max times to be declared,
    maybe giving ability to disallow certain times to be selected?
      ^ might not need it if combination of min/max times and setting
        increment amounts achieves same purpose
*/

/**
 * A TimePicker component containing inputs and a container with two to four ticker
 * components for hours, minutes, an optional seconds, and an optional AM/PM. */

var TimePicker = function (_React$Component) {
  _inherits(TimePicker, _React$Component);

  /**
   * Create a time picker. Determines if we can use browser native time type input
   * or if we need to fall back to a text type input (based on support).
   * @param {object} props - the props
   */
  function TimePicker(props) {
    _classCallCheck(this, TimePicker);

    var _this = _possibleConstructorReturn(this, (TimePicker.__proto__ || Object.getPrototypeOf(TimePicker)).call(this, props));

    _this.useGoodTimeInput = useGoodTimeInput();
    _this.state = _extends({
      isOpen: _this.props.isOpen || false,
      focused: false
    }, _this.valuesFromProps(props), {
      // Generation exists to force the inputs in the component to accept the
      // new value when we click a ticker
      generation: 0,
      mousedIn: false
    });
    return _this;
  }

  /**
   * Handle updated props from up the chain. In particular, if we receive a new
   * time from up the hierarchy, we want to reset the inputs and the tickers to
   * that value.
   * @param {object} nextProps - the nextProps
   * @return {void}
   */


  _createClass(TimePicker, [{
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      this.setState(this.valuesFromProps(nextProps));
    }

    /**
     * Find the time value from the props, and convert it to two values-- an iso
     * time and a 'local' format time version (so we can deal with poorly formatted
     * text inputs intelligently).
     * @param {object} props - the props
     * @return {object} an object with two keys: isoValue & formattedValue
     */

  }, {
    key: 'valuesFromProps',
    value: function valuesFromProps(props) {
      return this.valuesFromIso(props.defaultValue || props.value);
    }

    /**
     * Take an ISO formatted time and turn it into an object with iso and local
     * format time.
     * @param {string} iso - an iso format time
     * @return {object} an object with two keys: isoValue & formattedValue
     */

  }, {
    key: 'valuesFromIso',
    value: function valuesFromIso(iso) {
      return {
        isoValue: iso,
        formattedValue: this.isoToFormatted(iso)
      };
    }

    /**
     * Take an iso formatted time and put it into this picker's format
     * @param {string} iso - an iso format time
     * @return {string} a time formatted according to the format of this time picker
     */

  }, {
    key: 'isoToFormatted',
    value: function isoToFormatted(iso) {
      if (!iso) {
        return '';
      }
      return _luxon.DateTime.fromISO(iso).toFormat(this.timeFormat);
    }

    /**
     * Process change events from the input by updating the isoValue & formattedValue
     * of this component. Will call down to an onChange handler passed in.
     * @param {Event} event - the change event fired from the input
     * @return {void}
     */

  }, {
    key: 'onChange',
    value: function onChange(event) {
      // Take whatever format the input gave us, and turn it into an ISO time string
      var asISO = _luxon.DateTime.fromFormat(event.target.value, this.timeFormat).toISOTime();

      if (this.props.onChange) {
        // Call into an onChange we got as props
        this.props.onChange(event);
      }

      // Update isoValue & formattedValue from the ISO we built
      this.setState(this.valuesFromIso(asISO));
    }

    /**
     * Return the time format the component is using. Will be 'HH:mm' (or HH:mm:ss if seconds are to be
     * shown) if we are using a well supported time input. If we have fallen back
     * to text field due to bad support, this will be 'hh:mm a' (or 'hh:mm:ss a' if seconds are to be shown).
     * @return {string} the time format in use by the component
     */
    /* eslint complexity: [2, 4] */

  }, {
    key: 'updateTime',


    /**
     * Invoked by a time ticker to tell the time picker to update the inputs (onClick
     * of the ticker buttons).
     * @param {string} time - the new time, in the format hh:mm
     * @return {void}
     */
    value: function updateTime(time) {
      var _this2 = this;

      // Update isoValue & formattedValue based on the time value (which is an iso
      // time)
      this.setState(this.valuesFromIso(time), function () {
        // Update the native input value with the formatted version of the new time
        // (this prevents the native input value from sticking with a hand-typed
        // input value after the button is clicked in certain situations)
        // It also sets us up to fire off a synthetic change event that looks just
        // like change event from a typed input (so external change handlers are
        // properly) invoked
        var nativeInputValueSetter = Object.getOwnPropertyDescriptor(window.HTMLInputElement.prototype, 'value').set;

        nativeInputValueSetter.call(_this2.nativeInput, _this2.isoToFormatted(time));

        _this2.fireChangeHandler();

        // Force the input to be focused again (so that we don't immediately close
        // the ticker container because the button click makes us not focused on the input)
        _this2.refocusOnClick();
      });
    }

    /**
     * Create a synthetic change event and send it into the change handlers as if
     * the user had typed the new value. This makes typed input and time ticker button
     * clicks fire off the same handlers.
     * @return {void}
     */

  }, {
    key: 'fireChangeHandler',
    value: function fireChangeHandler() {
      var event = new Event('change', { bubbles: true, cancelable: false });

      this.nativeInput.dispatchEvent(event);
      this.onChange(event);
    }

    /**
     * Mark the input as in focus. Used to determine whether the time ticker container should
     * be open.
     * @param {Event} event - the focus event
     * @return {void}
     */

  }, {
    key: 'onFocus',
    value: function onFocus(event) {
      if (this.props.onFocus) {
        this.props.onFocus(event);
      }

      this.setState({ focused: true, isOpen: true });
    }

    /**
     * Mark the input as out of focus. Used to determine whether the time ticker container should
     * be closed.
     * @param {Event} event - the blur event
     * @return {void}
     */

  }, {
    key: 'onBlur',
    value: function onBlur(event) {
      if (this.props.onBlur) {
        this.props.onBlur(event);
      }

      this.setState({ focused: false, isOpen: this.state.mousedIn });
    }

    /**
     * Force the input back into focus. Used when time ticker buttons are clicked, so
     * that the input stays in focus and we don't close the container.
     * @return {void}
     */

  }, {
    key: 'refocusOnClick',
    value: function refocusOnClick() {
      if (this.nativeInput) {
        this.nativeInput.focus();
      }
      this.onFocus();
    }

    /**
     * Test whether we're on android or iphone. In that case, we hide the time picker
     * (unless we specify the usePickerOnMobile prop to force it). This is because
     * those platforms have native inputs for time which are much better for touch
     * than what we can do with time tickers.
     * @return {boolean} - true if on iOS or Android
     */

  }, {
    key: 'useNativePicker',
    value: function useNativePicker() {
      return typeof navigator !== 'undefined' && /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
    }

    /**
     * Track when the mouse cursor is over the component, so that we can not
     * immediately close the container when we lose focus-- which happens if you
     * click the container buttons.
     * @return {void}
     */

  }, {
    key: 'mouseIn',
    value: function mouseIn() {
      this.setState({ mousedIn: true });
    }

    /**
     * Track when the mouse is no longer over the component, which means that it
     * is safe to close the container if we lose focus, for example, because the
     * focus has moved to the next element.
     * @return {void}
     */

  }, {
    key: 'mouseOut',
    value: function mouseOut() {
      this.setState({ mousedIn: false, isOpen: this.state.focused });
    }

    /**
     * Returns true if the time container is opened, which is if:
     * - isOpen prop or state is set to true (state is true if the input is in focus)
     * - AND the input is not disabled
     * - AND we're not using the iOS / Android native picker (i.e. we're not on
     *   those platform OR we used props.useContainerOnMobile to force non-native
     *   input)
     * @returns {boolean} - true if the time container is open
     */
    /* eslint complexity: [2, 5] */

  }, {
    key: 'render',
    value: function render() {
      var _this3 = this;

      var _props = this.props,
          label = _props.label,
          error = _props.error,
          help = _props.help,
          use24hr = _props.use24hr,
          showSeconds = _props.showSeconds,
          overlay = _props.overlay,
          props = _objectWithoutProperties(_props, ['label', 'error', 'help', 'use24hr', 'showSeconds', 'overlay']);

      var nativeClass = this.useNativePicker() ? 'rev-TimePicker--native' : 'rev-TimePicker--custom';
      var timeInputProps = (0, _lodash.omit)(props, 'isOpen');

      return _react2.default.createElement(
        'label',
        {
          className: 'rev-TimePicker rev-InputLabel ' + nativeClass,
          onMouseOver: this.mouseIn.bind(this),
          onMouseOut: this.mouseOut.bind(this),
          onFocus: this.onFocus.bind(this),
          onBlur: this.onBlur.bind(this)
        },
        label,
        _react2.default.createElement(_TimeInput2.default, _extends({}, timeInputProps, {
          error: error,
          onFocus: this.onFocus.bind(this),
          onBlur: this.onBlur.bind(this),
          onChange: this.onChange.bind(this),
          useGoodTimeInput: this.useGoodTimeInput,
          showSeconds: showSeconds,
          formattedValue: this.state.formattedValue,
          generation: this.state.generation,
          inputRef: function inputRef(input) {
            return _this3.nativeInput = input;
          }
        })),
        _react2.default.createElement(
          _InputHelpText2.default,
          null,
          help
        ),
        _react2.default.createElement(
          _InputErrors2.default,
          null,
          error
        ),
        _react2.default.createElement(_TimeContainer2.default, _extends({}, props, {
          className: this.isContainerOpen ? 'rev-TimeContainer--open' : 'rev-TimeContainer--closed',
          selectedTime: this.state.isoValue,
          updateTime: this.updateTime.bind(this),
          refocusOnClick: this.refocusOnClick.bind(this),
          use24hr: use24hr,
          showSeconds: showSeconds,
          overlay: overlay
        }))
      );
    }
  }, {
    key: 'timeFormat',
    get: function get() {
      // TODO: detect locale default format string and use that instead of
      //   hardcoded 'HH:mm'
      if (this.useGoodTimeInput) {
        return this.props.showSeconds ? 'HH:mm:ss' : 'HH:mm';
      }
      return this.props.showSeconds ? 'hh:mm:ss a' : 'hh:mm a';
    }
  }, {
    key: 'isContainerOpen',
    get: function get() {
      return (this.state.isOpen || this.props.isOpen) && !this.props.disabled && (!this.useNativePicker() || this.props.usePickerOnMobile);
    }
  }]);

  return TimePicker;
}(_react2.default.Component);

TimePicker.propTypes = {
  label: _propTypes2.default.node,
  error: _propTypes2.default.node,
  help: _propTypes2.default.node,
  timeFormat: _propTypes2.default.string,
  use24hr: _propTypes2.default.bool,
  showSeconds: _propTypes2.default.bool,
  isOpen: _propTypes2.default.bool,
  disabled: _propTypes2.default.bool,
  onChange: _propTypes2.default.func,
  onFocus: _propTypes2.default.func,
  onBlur: _propTypes2.default.func,
  usePickerOnMobile: _propTypes2.default.bool,
  overlay: _propTypes2.default.bool
};

TimePicker.TimeInput = _TimeInput2.default;
TimePicker.TimeContainer = _TimeContainer2.default;
exports.TimeInput = _TimeInput2.default;
exports.TimeContainer = _TimeContainer2.default;
exports.default = TimePicker;
//# sourceMappingURL=TimePicker.js.map