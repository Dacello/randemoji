{"version":3,"sources":["../src/Sticky.js"],"names":["Sticky","props","state","isStuck","setContentState","bind","setWidth","window","addEventListener","placeholder","style","width","sticky","offsetWidth","height","offsetHeight","removeEventListener","value","parseInt","replace","parentElement","clientWidth","anchor","anchorParts","exec","anchorEl","document","getElementById","anchorPoint","getBoundingClientRect","bottom","top","stickyStart","stickyStop","topAnchor","bottomAnchor","getAnchor","currentHeight","stickyContainer","containerTop","containerBottom","topPoint","bottomPoint","topOffset","bottomOffset","stickToBottom","windowHeight","innerHeight","stickyPoints","setStickyPoints","stickyFlag","anchorFlag","display","setState","clientHeight","parsePxValue","children","className","stickyClass","stickyClassName","divProps","Object","assign","Component","propTypes","PropTypes","string","node","bool","number","StickyContainer","containerClassName","Container"],"mappings":"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","file":"Sticky.js","sourcesContent":["import React, {Component, Fragment} from 'react'\nimport PropTypes from 'prop-types'\nimport classNames from 'classnames'\n\n/**\n * A Sticky component that allows its content to stick\n * to the top or bottom of the window.\n */\nclass Sticky extends Component {\n  static propTypes = {\n    className: PropTypes.string,\n    children: PropTypes.node,\n    stickToBottom: PropTypes.bool,\n    topAnchor: PropTypes.string,\n    bottomAnchor: PropTypes.string,\n    topOffset: PropTypes.number,\n    bottomOffset: PropTypes.number,\n  }\n\n  constructor(props) {\n    super(props)\n    this.state = {isStuck: false}\n\n    this.setContentState = this.setContentState.bind(this)\n    this.setWidth = this.setWidth.bind(this)\n  }\n\n  /**\n   * Set the function that determines stickiness as the window scroll event and set\n   * the width setting function on window resize and load when the component mounts.\n   * @return {void}\n   */\n  componentDidMount() {\n    window.addEventListener('scroll', this.setContentState)\n    window.addEventListener('resize', this.setWidth)\n    window.addEventListener('load', this.setWidth)\n\n    this.placeholder.style.width = `${this.sticky.offsetWidth}px`\n    this.placeholder.style.height = `${this.sticky.offsetHeight}px`\n  }\n\n  /**\n   * Remove all the event listeners added on mount when the component unmounts.\n   * @return {void}\n   */\n  componentWillUnmount() {\n    window.removeEventListener('scroll', this.setContentState)\n    window.removeEventListener('resize', this.setWidth)\n    window.removeEventListener('load', this.setWidth)\n  }\n\n  /**\n   * Convert a string value of a quantity in px to an integer of the numeric\n   * value of the quantity. For example, passing in the string '18px' will return\n   * the integer 18.\n   * @param {string} value the value in px to convert\n   * @return {int} the parsed px value as an integer\n   */\n  parsePxValue(value) {\n    return parseInt(value.replace('px', ''), 10)\n  }\n\n  /**\n   * Set the width of the content block.\n   * @return {void}\n   */\n  setWidth() {\n    // use clientWidth here instead of offsetWidth\n    // because this value is used to contain the sticky\n    // element INSIDE of its parents borders\n    this.sticky.style.width = `${this.sticky.parentElement.clientWidth}px`\n  }\n\n  /**\n   * Takes one of the anchor prop values and determines\n   * whether to anchor to the top or bottom of the element\n   * @param {string} anchor the anchor prop value\n   * @return {string} the parsed anchor point\n   */\n  getAnchor(anchor) {\n    const anchorParts = /(\\w+):?(\\w*)/.exec(anchor)\n    const anchorEl = document.getElementById(anchorParts[1])\n    let anchorPoint\n\n    if (anchorParts[2] === 'bottom') {\n      anchorPoint = anchorEl.getBoundingClientRect().bottom\n    } else if (anchorParts[2] === 'top' || !anchorParts[2]) {\n      anchorPoint = anchorEl.getBoundingClientRect().top\n    }\n\n    return anchorPoint\n  }\n\n  /**\n   * Determine the points at which the sticky element starts to\n   * stick and stops sticking depending on which props are passed in.\n   * The stickToBottom prop sticks the sticky element to the bottom of the window.\n   * The topAnchor prop changes the starting point for a top-sticking sticky and\n   * the stopping point for a bottom-sticking sticky. The bottomAnchor changes the\n   * stopping point for a top-sticking sticky and the starting point for a\n   * bottom-sticking sticky.\n   * @return {object} the sticky starting and stopping points\n   */\n  setStickyPoints() {\n    let stickyStart, stickyStop, topAnchor, bottomAnchor\n\n    if (this.props.topAnchor) {\n      topAnchor = this.getAnchor(this.props.topAnchor)\n    }\n\n    if (this.props.bottomAnchor) {\n      bottomAnchor = this.getAnchor(this.props.bottomAnchor)\n    }\n\n    const currentHeight = this.sticky.offsetHeight\n\n    const stickyContainer = this.sticky.parentElement.parentElement\n      .parentElement\n    const containerTop = stickyContainer.getBoundingClientRect().top\n    const containerBottom = stickyContainer.getBoundingClientRect().bottom\n\n    let topPoint = topAnchor ? topAnchor : containerTop\n    let bottomPoint = bottomAnchor ? bottomAnchor : containerBottom\n\n    if (this.props.topOffset) {\n      topPoint += this.props.topOffset\n    }\n\n    if (this.props.bottomOffset) {\n      bottomPoint += this.props.bottomOffset\n    }\n\n    if (this.props.stickToBottom) {\n      const windowHeight = window.innerHeight\n\n      stickyStart = bottomPoint - windowHeight\n      stickyStop = topPoint + currentHeight - windowHeight\n    } else {\n      stickyStart = topPoint\n      stickyStop = bottomPoint - currentHeight\n    }\n\n    return {\n      stickyStart,\n      stickyStop,\n    }\n  }\n\n  /* eslint complexity: [2, 8] */\n  /**\n   * Determine the state of whether the content should be stuck, anchored to the stopping\n   * point of the sticky behavior (e.g. the bottom of the container), or neither.\n   * @return {void}\n   */\n  setContentState() {\n    const stickyPoints = this.setStickyPoints()\n    let stickyFlag, anchorFlag\n\n    if (this.props.stickToBottom) {\n      stickyFlag = stickyPoints.stickyStart > 0 && stickyPoints.stickyStop <= 0\n      anchorFlag = stickyPoints.stickyStart <= 0\n    } else {\n      stickyFlag = stickyPoints.stickyStart <= 0 && stickyPoints.stickyStop > 0\n      anchorFlag = stickyPoints.stickyStop <= 0\n    }\n\n    if (stickyFlag) {\n      if (this.props.stickToBottom) {\n        this.sticky.style.top = 'auto'\n        this.sticky.style.bottom = '0px'\n      } else {\n        this.sticky.style.top = '0px'\n      }\n\n      this.placeholder.style.display = 'block'\n      this.setState({isStuck: true})\n    } else {\n      if (anchorFlag) {\n        this.sticky.style.top = `${this.sticky.parentElement.parentElement\n          .parentElement.clientHeight -\n          this.parsePxValue(this.placeholder.style.height)}px`\n      }\n\n      this.placeholder.style.display = 'none'\n      this.setState({isStuck: false})\n    }\n  }\n\n  render() {\n    const {children, className, ...props} = this.props\n    /* eslint-disable no-nested-ternary */\n    const stickyClass = this.state.isStuck ? 'rev-Sticky--stuck' : ''\n    const stickyClassName = classNames(className, 'rev-Sticky', stickyClass)\n    const divProps = Object.assign({}, props)\n\n    delete divProps.stickToBottom\n    delete divProps.topAnchor\n    delete divProps.bottomAnchor\n    delete divProps.topOffset\n    delete divProps.bottomOffset\n\n    return (\n      <div className=\"rev-Sticky-wrapper\">\n        <div\n          className=\"rev-Sticky-placeholder\"\n          ref={(placeholder) => {\n            this.placeholder = placeholder\n          }}\n        />\n        <div\n          className={stickyClassName}\n          ref={(sticky) => {\n            this.sticky = sticky\n          }}\n          {...divProps}\n        >\n          {children}\n        </div>\n      </div>\n    )\n  }\n}\n\n/**\n * A StickyContainer component to hold a Sticky element.\n */\nclass StickyContainer extends Component {\n  static propTypes = {\n    className: PropTypes.string,\n    children: PropTypes.node,\n  }\n\n  constructor(props) {\n    super(props)\n  }\n\n  render() {\n    const {children, className, ...props} = this.props\n    const containerClassName = classNames(className, 'rev-Sticky-container')\n\n    return (\n      <div {...props} className={containerClassName}>\n        {children}\n      </div>\n    )\n  }\n}\n\nSticky.Container = StickyContainer\n\nexport {StickyContainer}\nexport default Sticky\n"]}