'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StickyContainer = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * A Sticky component that allows its content to stick
 * to the top or bottom of the window.
 */
var Sticky = function (_Component) {
  _inherits(Sticky, _Component);

  function Sticky(props) {
    _classCallCheck(this, Sticky);

    var _this = _possibleConstructorReturn(this, (Sticky.__proto__ || Object.getPrototypeOf(Sticky)).call(this, props));

    _this.state = { isStuck: false };

    _this.setContentState = _this.setContentState.bind(_this);
    _this.setWidth = _this.setWidth.bind(_this);
    return _this;
  }

  /**
   * Set the function that determines stickiness as the window scroll event and set
   * the width setting function on window resize and load when the component mounts.
   * @return {void}
   */


  _createClass(Sticky, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      window.addEventListener('scroll', this.setContentState);
      window.addEventListener('resize', this.setWidth);
      window.addEventListener('load', this.setWidth);

      this.placeholder.style.width = this.sticky.offsetWidth + 'px';
      this.placeholder.style.height = this.sticky.offsetHeight + 'px';
    }

    /**
     * Remove all the event listeners added on mount when the component unmounts.
     * @return {void}
     */

  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      window.removeEventListener('scroll', this.setContentState);
      window.removeEventListener('resize', this.setWidth);
      window.removeEventListener('load', this.setWidth);
    }

    /**
     * Convert a string value of a quantity in px to an integer of the numeric
     * value of the quantity. For example, passing in the string '18px' will return
     * the integer 18.
     * @param {string} value the value in px to convert
     * @return {int} the parsed px value as an integer
     */

  }, {
    key: 'parsePxValue',
    value: function parsePxValue(value) {
      return parseInt(value.replace('px', ''), 10);
    }

    /**
     * Set the width of the content block.
     * @return {void}
     */

  }, {
    key: 'setWidth',
    value: function setWidth() {
      // use clientWidth here instead of offsetWidth
      // because this value is used to contain the sticky
      // element INSIDE of its parents borders
      this.sticky.style.width = this.sticky.parentElement.clientWidth + 'px';
    }

    /**
     * Takes one of the anchor prop values and determines
     * whether to anchor to the top or bottom of the element
     * @param {string} anchor the anchor prop value
     * @return {string} the parsed anchor point
     */

  }, {
    key: 'getAnchor',
    value: function getAnchor(anchor) {
      var anchorParts = /(\w+):?(\w*)/.exec(anchor);
      var anchorEl = document.getElementById(anchorParts[1]);
      var anchorPoint = void 0;

      if (anchorParts[2] === 'bottom') {
        anchorPoint = anchorEl.getBoundingClientRect().bottom;
      } else if (anchorParts[2] === 'top' || !anchorParts[2]) {
        anchorPoint = anchorEl.getBoundingClientRect().top;
      }

      return anchorPoint;
    }

    /**
     * Determine the points at which the sticky element starts to
     * stick and stops sticking depending on which props are passed in.
     * The stickToBottom prop sticks the sticky element to the bottom of the window.
     * The topAnchor prop changes the starting point for a top-sticking sticky and
     * the stopping point for a bottom-sticking sticky. The bottomAnchor changes the
     * stopping point for a top-sticking sticky and the starting point for a
     * bottom-sticking sticky.
     * @return {object} the sticky starting and stopping points
     */

  }, {
    key: 'setStickyPoints',
    value: function setStickyPoints() {
      var stickyStart = void 0,
          stickyStop = void 0,
          topAnchor = void 0,
          bottomAnchor = void 0;

      if (this.props.topAnchor) {
        topAnchor = this.getAnchor(this.props.topAnchor);
      }

      if (this.props.bottomAnchor) {
        bottomAnchor = this.getAnchor(this.props.bottomAnchor);
      }

      var currentHeight = this.sticky.offsetHeight;

      var stickyContainer = this.sticky.parentElement.parentElement.parentElement;
      var containerTop = stickyContainer.getBoundingClientRect().top;
      var containerBottom = stickyContainer.getBoundingClientRect().bottom;

      var topPoint = topAnchor ? topAnchor : containerTop;
      var bottomPoint = bottomAnchor ? bottomAnchor : containerBottom;

      if (this.props.topOffset) {
        topPoint += this.props.topOffset;
      }

      if (this.props.bottomOffset) {
        bottomPoint += this.props.bottomOffset;
      }

      if (this.props.stickToBottom) {
        var windowHeight = window.innerHeight;

        stickyStart = bottomPoint - windowHeight;
        stickyStop = topPoint + currentHeight - windowHeight;
      } else {
        stickyStart = topPoint;
        stickyStop = bottomPoint - currentHeight;
      }

      return {
        stickyStart: stickyStart,
        stickyStop: stickyStop
      };
    }

    /* eslint complexity: [2, 8] */
    /**
     * Determine the state of whether the content should be stuck, anchored to the stopping
     * point of the sticky behavior (e.g. the bottom of the container), or neither.
     * @return {void}
     */

  }, {
    key: 'setContentState',
    value: function setContentState() {
      var stickyPoints = this.setStickyPoints();
      var stickyFlag = void 0,
          anchorFlag = void 0;

      if (this.props.stickToBottom) {
        stickyFlag = stickyPoints.stickyStart > 0 && stickyPoints.stickyStop <= 0;
        anchorFlag = stickyPoints.stickyStart <= 0;
      } else {
        stickyFlag = stickyPoints.stickyStart <= 0 && stickyPoints.stickyStop > 0;
        anchorFlag = stickyPoints.stickyStop <= 0;
      }

      if (stickyFlag) {
        if (this.props.stickToBottom) {
          this.sticky.style.top = 'auto';
          this.sticky.style.bottom = '0px';
        } else {
          this.sticky.style.top = '0px';
        }

        this.placeholder.style.display = 'block';
        this.setState({ isStuck: true });
      } else {
        if (anchorFlag) {
          this.sticky.style.top = this.sticky.parentElement.parentElement.parentElement.clientHeight - this.parsePxValue(this.placeholder.style.height) + 'px';
        }

        this.placeholder.style.display = 'none';
        this.setState({ isStuck: false });
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          children = _props.children,
          className = _props.className,
          props = _objectWithoutProperties(_props, ['children', 'className']);
      /* eslint-disable no-nested-ternary */


      var stickyClass = this.state.isStuck ? 'rev-Sticky--stuck' : '';
      var stickyClassName = (0, _classnames2.default)(className, 'rev-Sticky', stickyClass);
      var divProps = Object.assign({}, props);

      delete divProps.stickToBottom;
      delete divProps.topAnchor;
      delete divProps.bottomAnchor;
      delete divProps.topOffset;
      delete divProps.bottomOffset;

      return _react2.default.createElement(
        'div',
        { className: 'rev-Sticky-wrapper' },
        _react2.default.createElement('div', {
          className: 'rev-Sticky-placeholder',
          ref: function ref(placeholder) {
            _this2.placeholder = placeholder;
          }
        }),
        _react2.default.createElement(
          'div',
          _extends({
            className: stickyClassName,
            ref: function ref(sticky) {
              _this2.sticky = sticky;
            }
          }, divProps),
          children
        )
      );
    }
  }]);

  return Sticky;
}(_react.Component);

/**
 * A StickyContainer component to hold a Sticky element.
 */


Sticky.propTypes = {
  className: _propTypes2.default.string,
  children: _propTypes2.default.node,
  stickToBottom: _propTypes2.default.bool,
  topAnchor: _propTypes2.default.string,
  bottomAnchor: _propTypes2.default.string,
  topOffset: _propTypes2.default.number,
  bottomOffset: _propTypes2.default.number
};

var StickyContainer = function (_Component2) {
  _inherits(StickyContainer, _Component2);

  function StickyContainer(props) {
    _classCallCheck(this, StickyContainer);

    return _possibleConstructorReturn(this, (StickyContainer.__proto__ || Object.getPrototypeOf(StickyContainer)).call(this, props));
  }

  _createClass(StickyContainer, [{
    key: 'render',
    value: function render() {
      var _props2 = this.props,
          children = _props2.children,
          className = _props2.className,
          props = _objectWithoutProperties(_props2, ['children', 'className']);

      var containerClassName = (0, _classnames2.default)(className, 'rev-Sticky-container');

      return _react2.default.createElement(
        'div',
        _extends({}, props, { className: containerClassName }),
        children
      );
    }
  }]);

  return StickyContainer;
}(_react.Component);

StickyContainer.propTypes = {
  className: _propTypes2.default.string,
  children: _propTypes2.default.node
};


Sticky.Container = StickyContainer;

exports.StickyContainer = StickyContainer;
exports.default = Sticky;
//# sourceMappingURL=Sticky.js.map