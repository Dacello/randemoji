'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _luxon = require('luxon');

var _lodash = require('lodash');

var _CalendarHeaderRow = require('./CalendarHeaderRow');

var _CalendarHeaderRow2 = _interopRequireDefault(_CalendarHeaderRow);

var _CalendarWeekRow = require('./CalendarWeekRow');

var _CalendarWeekRow2 = _interopRequireDefault(_CalendarWeekRow);

var _Card = require('../Card');

var _Card2 = _interopRequireDefault(_Card);

var _Icon = require('../Icon');

var _Icon2 = _interopRequireDefault(_Icon);

var _Button = require('../Button');

var _Button2 = _interopRequireDefault(_Button);

var _createElementWithOverride = require('../Utilities/createElementWithOverride');

var _createElementWithOverride2 = _interopRequireDefault(_createElementWithOverride);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx createElement */


/**
 * A component representing a Calendar for a given focus month (& including the
 * leading days of the first week and trailing days of the last week).
 */
var Calendar = function (_Component) {
  _inherits(Calendar, _Component);

  _createClass(Calendar, null, [{
    key: 'defaultProps',


    /**
     * The default values for props of this component
     * @return {object} the default value object
     */
    get: function get() {
      var createElement = _react2.default.createElement;

      return {
        nextLabel: createElement(
          'span',
          null,
          '\u203A'
        ),
        previousLabel: createElement(
          'span',
          null,
          '\u2039'
        ),
        dateChanger: function dateChanger() {
          return null;
        },
        focuser: function focuser() {
          return null;
        },
        isSelectable: function isSelectable() {
          return true;
        }
      };
    }

    /**
     * Creates a Calendar. Sets state.date to a Luxon DateTime based on the
     * selectedDate prop.
     * @param {*} props - the props
     */

  }]);

  function Calendar(props) {
    _classCallCheck(this, Calendar);

    var _this = _possibleConstructorReturn(this, (Calendar.__proto__ || Object.getPrototypeOf(Calendar)).call(this, props));

    _this.state = {
      date: _this.asLuxon(_this.props.selectedDate)
    };
    return _this;
  }

  /**
   * Update state when props change. In particular, if we receive a different
   * `selectedDate` prop from up the hierarchy, set state.date to a new Luxon
   * DateTime appropriately (in order to force the calendar to focus on the new
   * date).
   * @param {*} nextProps - the next props
   * @return {void}
   */


  _createClass(Calendar, [{
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (nextProps.selectedDate !== this.props.selectedDate) {
        this.setState({ date: this.asLuxon(nextProps.selectedDate) });
      }
    }

    /**
     * Convert an iso date string to a Luxon DateTime. If iso date is blank / null,
     * or invalid (e.g. 2018-06-66), return the local current date instead.
     * @param {string} date - the date to convert, as either an iso date, or a
     *   blank / null
     * @return {DateTime} - a local DateTime
     */

  }, {
    key: 'asLuxon',
    value: function asLuxon(date) {
      if (!date) {
        return _luxon.DateTime.local();
      }

      var luxon = _luxon.DateTime.fromISO(date);

      if (luxon.invalid) {
        return _luxon.DateTime.local();
      }
      return luxon;
    }

    /**
     * The start of the month of that the current focus date is in (e.g. if the
     * input is filled with 2018-08-05 then this value is 2018-08-1).
     * @returns {DateTime} - a Luxon DateTime represented the first day of the
     *   month in question.
     */

  }, {
    key: 'startOfMonth',
    value: function startOfMonth() {
      return this.state.date.startOf('month');
    }

    /**
     * Returns the nearest Sunday falling on or before the start of the month.
     * This is the first day of the first row of the calendar display. Note that
     * this date is either equal to startOfMonth (if the month starts on a Sunday)
     * or in the previous month (if the month starts on a different day of the
     * week).
     * @returns {DateTime} - a Luxon DateTime representing the Sunday when the first
     *   week of the focus month starts.
     */

  }, {
    key: 'startOfWeekOfStartOfMonth',
    value: function startOfWeekOfStartOfMonth() {
      var weekday = this.startOfMonth().weekday % 7;

      return this.startOfMonth().minus(_luxon.Duration.fromObject({ days: weekday }));
    }

    /**
     * Move the focus month up n months (or back |n| months if n is negative).
     * It moves it to n months from startOfMonth to handle advancing between
     * months with different numbers of days (2018-01-31 + 1 month in Luxon =
     * 2018-03-03). We actually want Jan -> Feb -> Mar which only works if we do
     * (2018-01-31).startOfMonth() + 1month = 2018-02-01.
     *
     * This function does not change the date in the input (only calendar display,
     * so we can get away with using the first of the month like this.
     * @param {int} num - the number of months to move the focus month
     * @param {Event} event - the event that caused this handler to be invoked
     *   (e.g. the click event from the next or previous button on the calendar)
     * @return {void}
     */

  }, {
    key: 'addMonth',
    value: function addMonth(num, event) {
      event.preventDefault();
      this.setState({
        date: this.startOfMonth().plus(_luxon.Duration.fromObject({ month: num }))
      });
      if (this.props.focuser) {
        this.props.focuser();
      }
    }

    /**
     * Move the focus year up n years (or back |n| years if n is negative).
     *
     * This function does not change the date in the input (only calendar display,
     * so we can get away with using the first of the month like this.
     * @param {int} num - the number of years to move the focus year
     * @param {Event} event - the event that caused this handler to be invoked
     *   (e.g. the click event from the next or previous button on the calendar)
     * @return {void}
     */

  }, {
    key: 'addYear',
    value: function addYear(num, event) {
      event.preventDefault();
      this.setState({
        date: this.startOfMonth().plus(_luxon.Duration.fromObject({ year: num }))
      });
      if (this.props.focuser) {
        this.props.focuser();
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          className = _props.className,
          week = _props.week,
          overrides = _props.overrides,
          day = _props.day,
          headerDay = _props.headerDay,
          isSelectable = _props.isSelectable,
          dateChanger = _props.dateChanger,
          selectedDate = _props.selectedDate,
          highlights = _props.highlights,
          nextLabel = _props.nextLabel,
          previousLabel = _props.previousLabel,
          overlay = _props.overlay,
          getCalendarRef = _props.getCalendarRef,
          showYearSelection = _props.showYearSelection,
          props = _objectWithoutProperties(_props, ['className', 'week', 'overrides', 'day', 'headerDay', 'isSelectable', 'dateChanger', 'selectedDate', 'highlights', 'nextLabel', 'previousLabel', 'overlay', 'getCalendarRef', 'showYearSelection']);

      var createElement = _createElementWithOverride2.default.bind(this, overrides);
      var divProps = (0, _lodash.omit)(props, 'focuser');

      return createElement(
        'div',
        _extends({}, divProps, {
          className: 'rev-Calendar ' + (overlay ? 'rev-Calendar--overlay' : '') + ' ' + className
        }),
        createElement(
          _Card2.default,
          { getCalendarRef: getCalendarRef },
          createElement(
            _Card2.default.Header,
            { className: 'rev-Calendar-header' },
            createElement(
              'button',
              {
                onClick: this.addMonth.bind(this, -1),
                className: 'rev-Calendar-header-button rev-Calendar-header-button--previous',
                'aria-label': 'Previous Month'
              },
              previousLabel
            ),
            createElement(
              'span',
              { className: 'rev-Calendar-header-label' },
              this.state.date.toLocaleString({
                month: 'short',
                year: 'numeric'
              })
            ),
            showYearSelection && createElement(
              'div',
              { className: 'rev-Calender-year-selection' },
              createElement(
                _Button2.default,
                {
                  small: true,
                  className: 'rev-Calendar-year-selection-button',
                  onClick: this.addYear.bind(this, 1)
                },
                createElement(
                  'span',
                  null,
                  '\u02C4'
                )
              ),
              createElement(
                _Button2.default,
                {
                  small: true,
                  className: 'rev-Calendar-year-selection-button',
                  onClick: this.addYear.bind(this, -1)
                },
                createElement(
                  'span',
                  null,
                  '\u02C5'
                )
              )
            ),
            createElement(
              'button',
              {
                onClick: this.addMonth.bind(this, 1),
                className: 'rev-Calendar-header-button rev-Calendar-header-button--next',
                'aria-label': 'Next Month'
              },
              nextLabel
            )
          ),
          createElement(
            'table',
            { className: 'rev-Calendar-body' },
            createElement(_CalendarHeaderRow2.default, {
              firstDay: this.startOfWeekOfStartOfMonth(),
              overrides: overrides,
              headerDay: headerDay
            }),
            createElement(
              'tbody',
              null,
              [0, 7, 14, 21, 28].map(function (i) {
                return createElement(_CalendarWeekRow2.default, _extends({}, week, {
                  day: day,
                  firstDay: _this2.startOfWeekOfStartOfMonth().plus({ days: i }),
                  currentMonth: _this2.state.date.toFormat('yyyy-MM'),
                  isSelectable: isSelectable,
                  dateChanger: dateChanger,
                  selectedDate: selectedDate,
                  highlights: highlights,
                  key: i
                }));
              })
            )
          )
        )
      );
    }
  }]);

  return Calendar;
}(_react.Component);

Calendar.propTypes = {
  selectedDate: _propTypes2.default.string,
  focuser: _propTypes2.default.func,
  isSelectable: _propTypes2.default.func,
  dateChanger: _propTypes2.default.func,
  overrides: _propTypes2.default.object,
  week: _propTypes2.default.any,
  overlay: _propTypes2.default.bool,
  highlights: _propTypes2.default.any,
  headerDay: _propTypes2.default.any,
  day: _propTypes2.default.any,
  nextLabel: _propTypes2.default.node,
  previousLabel: _propTypes2.default.node,
  className: _propTypes2.default.string,
  getCalendarRef: _propTypes2.default.func,
  showYearSelection: _propTypes2.default.bool };
exports.default = Calendar;
//# sourceMappingURL=Calendar.js.map