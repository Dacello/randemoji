{"version":3,"sources":["../src/TimePicker.js"],"names":["useGoodTimeInput","window","element","document","createElement","type","TimePicker","props","state","isOpen","focused","valuesFromProps","generation","mousedIn","nextProps","setState","valuesFromIso","defaultValue","value","iso","isoValue","formattedValue","isoToFormatted","DateTime","fromISO","toFormat","timeFormat","event","asISO","fromFormat","target","toISOTime","onChange","time","nativeInputValueSetter","Object","getOwnPropertyDescriptor","HTMLInputElement","prototype","set","call","nativeInput","fireChangeHandler","refocusOnClick","Event","bubbles","cancelable","dispatchEvent","onFocus","onBlur","focus","navigator","test","userAgent","label","error","help","use24hr","showSeconds","overlay","nativeClass","useNativePicker","timeInputProps","mouseIn","bind","mouseOut","input","isContainerOpen","updateTime","disabled","usePickerOnMobile","React","Component","propTypes","PropTypes","node","string","bool","func","TimeInput","TimeContainer"],"mappings":"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","file":"TimePicker.js","sourcesContent":["import React from 'react'\nimport PropTypes from 'prop-types'\nimport {omit} from 'lodash'\nimport TimeInput from './TimePicker/TimeInput'\nimport TimeContainer from './TimePicker/TimeContainer'\nimport InputHelpText from './InputHelpText'\nimport InputErrors from './InputErrors'\nimport {DateTime} from 'luxon'\n\n/**\n * Determines if time type inputs are well supported on this platform\n * @return {boolean} true if time type inputs are well supported, false otherwise\n */\nfunction useGoodTimeInput() {\n  if (typeof window === 'undefined') {\n    return true\n  } else {\n    const element = document.createElement('input')\n\n    element.type = 'time'\n    return element.type === 'time'\n  }\n}\n\n/* TODO FEATURES:\n    allow keyboard up & down to increment/decrement for accessibility concerns,\n    overrides,\n    allow setting how much each button should increment,\n    allowing min and/or max times to be declared,\n    maybe giving ability to disallow certain times to be selected?\n      ^ might not need it if combination of min/max times and setting\n        increment amounts achieves same purpose\n*/\n\n/**\n * A TimePicker component containing inputs and a container with two to four ticker\n * components for hours, minutes, an optional seconds, and an optional AM/PM. */\nclass TimePicker extends React.Component {\n  /**\n   * Create a time picker. Determines if we can use browser native time type input\n   * or if we need to fall back to a text type input (based on support).\n   * @param {object} props - the props\n   */\n  constructor(props) {\n    super(props)\n    this.useGoodTimeInput = useGoodTimeInput()\n    this.state = {\n      isOpen: this.props.isOpen || false,\n      focused: false,\n      // Handles setting both the iso and 'local' format versions of the time\n      // into state. We do this so that we can always accept ISO times from\n      // up the hierarchy, but also handle accepting change events from unchecked\n      // oddly formatted text inputs\n      ...this.valuesFromProps(props),\n      // Generation exists to force the inputs in the component to accept the\n      // new value when we click a ticker\n      generation: 0,\n      mousedIn: false,\n    }\n  }\n\n  /**\n   * Handle updated props from up the chain. In particular, if we receive a new\n   * time from up the hierarchy, we want to reset the inputs and the tickers to\n   * that value.\n   * @param {object} nextProps - the nextProps\n   * @return {void}\n   */\n  componentWillReceiveProps(nextProps) {\n    this.setState(this.valuesFromProps(nextProps))\n  }\n\n  /**\n   * Find the time value from the props, and convert it to two values-- an iso\n   * time and a 'local' format time version (so we can deal with poorly formatted\n   * text inputs intelligently).\n   * @param {object} props - the props\n   * @return {object} an object with two keys: isoValue & formattedValue\n   */\n  valuesFromProps(props) {\n    return this.valuesFromIso(props.defaultValue || props.value)\n  }\n\n  /**\n   * Take an ISO formatted time and turn it into an object with iso and local\n   * format time.\n   * @param {string} iso - an iso format time\n   * @return {object} an object with two keys: isoValue & formattedValue\n   */\n  valuesFromIso(iso) {\n    return {\n      isoValue: iso,\n      formattedValue: this.isoToFormatted(iso),\n    }\n  }\n\n  /**\n   * Take an iso formatted time and put it into this picker's format\n   * @param {string} iso - an iso format time\n   * @return {string} a time formatted according to the format of this time picker\n   */\n  isoToFormatted(iso) {\n    if (!iso) {\n      return ''\n    }\n    return DateTime.fromISO(iso).toFormat(this.timeFormat)\n  }\n\n  /**\n   * Process change events from the input by updating the isoValue & formattedValue\n   * of this component. Will call down to an onChange handler passed in.\n   * @param {Event} event - the change event fired from the input\n   * @return {void}\n   */\n  onChange(event) {\n    // Take whatever format the input gave us, and turn it into an ISO time string\n    const asISO = DateTime.fromFormat(\n      event.target.value,\n      this.timeFormat\n    ).toISOTime()\n\n    if (this.props.onChange) {\n      // Call into an onChange we got as props\n      this.props.onChange(event)\n    }\n\n    // Update isoValue & formattedValue from the ISO we built\n    this.setState(this.valuesFromIso(asISO))\n  }\n\n  /**\n   * Return the time format the component is using. Will be 'HH:mm' (or HH:mm:ss if seconds are to be\n   * shown) if we are using a well supported time input. If we have fallen back\n   * to text field due to bad support, this will be 'hh:mm a' (or 'hh:mm:ss a' if seconds are to be shown).\n   * @return {string} the time format in use by the component\n   */\n  /* eslint complexity: [2, 4] */\n  get timeFormat() {\n    // TODO: detect locale default format string and use that instead of\n    //   hardcoded 'HH:mm'\n    if (this.useGoodTimeInput) {\n      return this.props.showSeconds ? 'HH:mm:ss' : 'HH:mm'\n    }\n    return this.props.showSeconds ? 'hh:mm:ss a' : 'hh:mm a'\n  }\n\n  /**\n   * Invoked by a time ticker to tell the time picker to update the inputs (onClick\n   * of the ticker buttons).\n   * @param {string} time - the new time, in the format hh:mm\n   * @return {void}\n   */\n  updateTime(time) {\n    // Update isoValue & formattedValue based on the time value (which is an iso\n    // time)\n    this.setState(this.valuesFromIso(time), () => {\n      // Update the native input value with the formatted version of the new time\n      // (this prevents the native input value from sticking with a hand-typed\n      // input value after the button is clicked in certain situations)\n      // It also sets us up to fire off a synthetic change event that looks just\n      // like change event from a typed input (so external change handlers are\n      // properly) invoked\n      const nativeInputValueSetter = Object.getOwnPropertyDescriptor(\n        window.HTMLInputElement.prototype,\n        'value'\n      ).set\n\n      nativeInputValueSetter.call(this.nativeInput, this.isoToFormatted(time));\n\n      this.fireChangeHandler()\n\n      // Force the input to be focused again (so that we don't immediately close\n      // the ticker container because the button click makes us not focused on the input)\n      this.refocusOnClick()\n    })\n  }\n\n  /**\n   * Create a synthetic change event and send it into the change handlers as if\n   * the user had typed the new value. This makes typed input and time ticker button\n   * clicks fire off the same handlers.\n   * @return {void}\n   */\n  fireChangeHandler() {\n    const event = new Event('change', {bubbles: true, cancelable: false})\n\n    this.nativeInput.dispatchEvent(event)\n    this.onChange(event)\n  }\n\n  /**\n   * Mark the input as in focus. Used to determine whether the time ticker container should\n   * be open.\n   * @param {Event} event - the focus event\n   * @return {void}\n   */\n  onFocus(event) {\n    if (this.props.onFocus) {\n      this.props.onFocus(event)\n    }\n\n    this.setState({focused: true, isOpen: true})\n  }\n\n  /**\n   * Mark the input as out of focus. Used to determine whether the time ticker container should\n   * be closed.\n   * @param {Event} event - the blur event\n   * @return {void}\n   */\n  onBlur(event) {\n    if (this.props.onBlur) {\n      this.props.onBlur(event)\n    }\n\n    this.setState({focused: false, isOpen: this.state.mousedIn})\n  }\n\n  /**\n   * Force the input back into focus. Used when time ticker buttons are clicked, so\n   * that the input stays in focus and we don't close the container.\n   * @return {void}\n   */\n  refocusOnClick() {\n    if (this.nativeInput) {\n      this.nativeInput.focus()\n    }\n    this.onFocus()\n  }\n\n  /**\n   * Test whether we're on android or iphone. In that case, we hide the time picker\n   * (unless we specify the usePickerOnMobile prop to force it). This is because\n   * those platforms have native inputs for time which are much better for touch\n   * than what we can do with time tickers.\n   * @return {boolean} - true if on iOS or Android\n   */\n  useNativePicker() {\n    return (\n      typeof navigator !== 'undefined' &&\n      /Android|iPhone|iPad|iPod/i.test(navigator.userAgent)\n    )\n  }\n\n  /**\n   * Track when the mouse cursor is over the component, so that we can not\n   * immediately close the container when we lose focus-- which happens if you\n   * click the container buttons.\n   * @return {void}\n   */\n  mouseIn() {\n    this.setState({mousedIn: true})\n  }\n\n  /**\n   * Track when the mouse is no longer over the component, which means that it\n   * is safe to close the container if we lose focus, for example, because the\n   * focus has moved to the next element.\n   * @return {void}\n   */\n  mouseOut() {\n    this.setState({mousedIn: false, isOpen: this.state.focused})\n  }\n\n  /**\n   * Returns true if the time container is opened, which is if:\n   * - isOpen prop or state is set to true (state is true if the input is in focus)\n   * - AND the input is not disabled\n   * - AND we're not using the iOS / Android native picker (i.e. we're not on\n   *   those platform OR we used props.useContainerOnMobile to force non-native\n   *   input)\n   * @returns {boolean} - true if the time container is open\n   */\n  /* eslint complexity: [2, 5] */\n  get isContainerOpen() {\n    return (\n      (this.state.isOpen || this.props.isOpen) &&\n      !this.props.disabled &&\n      (!this.useNativePicker() || this.props.usePickerOnMobile)\n    )\n  }\n\n  render() {\n    const {\n      label,\n      error,\n      help,\n      use24hr,\n      showSeconds,\n      overlay,\n      ...props\n    } = this.props\n    const nativeClass = this.useNativePicker()\n      ? 'rev-TimePicker--native'\n      : 'rev-TimePicker--custom'\n    const timeInputProps = omit(props, 'isOpen')\n\n    return (\n      <label\n        className={`rev-TimePicker rev-InputLabel ${nativeClass}`}\n        onMouseOver={this.mouseIn.bind(this)}\n        onMouseOut={this.mouseOut.bind(this)}\n        onFocus={this.onFocus.bind(this)}\n        onBlur={this.onBlur.bind(this)}\n      >\n        {label}\n        <TimeInput\n          {...timeInputProps}\n          error={error}\n          onFocus={this.onFocus.bind(this)}\n          onBlur={this.onBlur.bind(this)}\n          onChange={this.onChange.bind(this)}\n          useGoodTimeInput={this.useGoodTimeInput}\n          showSeconds={showSeconds}\n          formattedValue={this.state.formattedValue}\n          generation={this.state.generation}\n          inputRef={(input) => (this.nativeInput = input)}\n        />\n        <InputHelpText>{help}</InputHelpText>\n        <InputErrors>{error}</InputErrors>\n        <TimeContainer\n          {...props}\n          className={\n            this.isContainerOpen\n              ? 'rev-TimeContainer--open'\n              : 'rev-TimeContainer--closed'\n          }\n          selectedTime={this.state.isoValue}\n          updateTime={this.updateTime.bind(this)}\n          refocusOnClick={this.refocusOnClick.bind(this)}\n          use24hr={use24hr}\n          showSeconds={showSeconds}\n          overlay={overlay}\n        />\n      </label>\n    )\n  }\n}\n\nTimePicker.propTypes = {\n  label: PropTypes.node,\n  error: PropTypes.node,\n  help: PropTypes.node,\n  timeFormat: PropTypes.string,\n  use24hr: PropTypes.bool,\n  showSeconds: PropTypes.bool,\n  isOpen: PropTypes.bool,\n  disabled: PropTypes.bool,\n  onChange: PropTypes.func,\n  onFocus: PropTypes.func,\n  onBlur: PropTypes.func,\n  usePickerOnMobile: PropTypes.bool,\n  overlay: PropTypes.bool,\n}\n\nTimePicker.TimeInput = TimeInput\nTimePicker.TimeContainer = TimeContainer\nexport {TimeInput, TimeContainer}\nexport default TimePicker\n"]}